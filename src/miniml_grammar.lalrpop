use std::str::FromStr;
use ast::{Type, Expr, TopLevelCmd, Tok};

grammar;

Int: i64 = <s:r"[0-9]+"> => i64::from_str(s).unwrap();
Tint: Tok = "int" => Tok::Tint;
Tbool: Tok = "bool" => Tok::Tbool;
True: Tok = "true" => Tok::True;
False: Tok = "false" => Tok::False;
Fun: Tok = "fun" => Tok::Fun;
Is: Tok = "is" => Tok::Is;
If: Tok = "if" => Tok::If;
Then: Tok = "then" => Tok::Then;
Else: Tok = "else" => Tok::Else;
Let: Tok = "let" => Tok::Let;
Semicolon2: Tok = ";;" => Tok::Semicolon2;
Equal: Tok = "=" => Tok::Equal;
Less: Tok = "<" => Tok::Less;
Tarrow: Tok = "->" => Tok::Tarrow;
Colon: Tok = ":" => Tok::Colon;
Lparen: Tok = "(" => Tok::Lparen;
Rparen: Tok = ")" => Tok::Rparen;
Plus: Tok = "+" => Tok::Plus;
Minus: Tok = "-" => Tok::Minus;
Times: Tok = "*" => Tok::Times;
Var: Expr = <s:r"[a-z_]+"> => Expr::Var(s.to_string());

pub Toplevel: Vec<TopLevelCmd> = {
    <Def> => vec![<>],
    <Def> ";;" => vec![<>]
};

Def: TopLevelCmd = {
    "unimplemented!" => TopLevelCmd::Expr(Expr::Var("foo".to_string()))
};

pub Bexpr: Box<Expr> = {
    // Nonapp,
    // App,
    // Arith,
    // Boolean
    "unimplemented!" => Box::new(Expr::Int(3))
};

App: Box<Expr> = {
    App Nonapp => Box::new(Expr::Apply(<>)),
    Nonapp Nonapp => Box::new(Expr::Apply(<>))
};

Nonapp: Box<Expr> = {
    Var => Box::new(<>),
    "true" => Box::new(Expr::Bool(true)),
    "false" => Box::new(Expr::Bool(false)),
    Int => Box::new(Expr::Int(<>)),
    "(" <Bexpr> ")" => <>
};

Arith: Box<Expr> = {
    "-" <Int> => Box::new(Expr::Int(<>)),
    <Bexpr> "+" <Bexpr> => Box::new(Expr::Plus(<>)),
    <Bexpr> "-" <Bexpr> => Box::new(Expr::Minus(<>)),
    <Bexpr> "*" <Bexpr> => Box::new(Expr::Times(<>))
};

Boolean: Box<Expr> = {
    <Bexpr> "=" <Bexpr> => Box::new(Expr::Equal(<>)),
    <Bexpr> "<" <Bexpr> => Box::new(Expr::Less(<>))
};

pub Ty: Type = {
    Ty1,
    <t1:Ty1> "->" <t2:Ty1> => Type::Arrow(Box::new(t1), Box::new(t2))
};

Ty1: Type = {
    "int" => Type::Int,
    "bool" => Type::Bool,
    "(" <Ty> ")"
};

